# 前言
在pnyx中，有大量的需要跨分片处理的交易，例如： 如果帐户Alice向Bob转移一笔资产，需要在Alice帐户中减去，然后在Bob帐户加上相应的值，在分片系统中，帐户alice和分属于两个不同的分片，要实现转帐的效果，需要做到以下的原子性：如果从Alice中扣除了资产，必须保证Bob中肯定能够收到资产；反之，如果从Alice中扣除失败，则肯定不会向Bob增加相应的资产。  
在实现上Alice所在的分片是无法也不应该关心Bob是否收到资产的，否则就会导致分片之间耦合性过强使系统无法工作。在Pnyx中，相应的处理方案是使用跨分片动作Cross-shard-actions，即需要跨分片处理的的动作，在原分片区块处理结束后，作为处理结果存放在区块体里，并且将对应的哈希放在区块头上。其他处理该区块的链，把这个区块看成是输入，然后处理区块体里的Cross-shard-actions。  
![](./imgs/cross-shard.png)  
为了一致性，我们将不同链的区块也作为交易的一种放入到区块中，这样可以享受系统使用substrate的pallet进行各种分开处理的好处。这种交易我们称为区块交易。区块交易的结果原始的跨分片交易的结果会有所不同

## 链外存储
在跨分片中，一种角色的链所生成的区块需要被其他角色的多个链中的节点读取和处理。比如信标链中的区块，会被所有中继链的节点读取和处理；而每一条中继链中的节点，只关心信标链中与自身相关的部分，而与自身不相关的数据最好不需要传输和处理，为了达到这个交易，我们提出了链外存储。  
链外存储是指数据哈希存储到链上（区块中），而数据放在链外，当其他节点有需要时，通过链外存储获取哈希对应的数据。通过这个方案可以降低非必要的数据传输。在上述的信标和中继链的例子中，中继链通过信标区块获得了一组Vec<(ChainRole,Hash）>，然后在这个数组中得到与自身ChainRole一致的哈希，向链外存储请求获取哈希对应的数据`Vec<Hash>`，这样与本身ChainRole不相干的数据，将不会在中继链中传输。  
链外存储的读写分成了两个阶段：向来源节点请求阶段和向P2P存储请求阶段。简单来说，需要依据下面的两个原则：
1. 只要某个节点向链外存储写入了（Hash,Data)对，经过一定的时候，系统中的任何节点都可以通过Hash能够得到相应的数据
2. 如果一个节点在区块中向另外一个节点提供了哈希，在对方节点提出请求时，需要能够将该哈希对应的数据提供给对方。

上述的第一条原则保证了数据的最终一致性，第二条原则保证了快速性。 在使用过程中，如果区块哈希获得的结果还是哈希，需要再次获取一次时，可以直接使用原则1，而不必要通过原则2，因此在实现时，可以提供两种不同的接口或是不同的参数。参考[这里](../3-网络层组件/2-链外存储.md)了解更多的关于链外存储的设计和实现

# 概要说明
跨分片交易过程中的数据设计：  
![](imgs/cross-shard-actions.png)
## 跨分片交易的处理过程
如上图所述，所有的交易本质上是分成两步执行的，
1. 原始交易的结果，原始交易执行的结果可能会产生一个Csaction，原始的交易执行时，如果需要产生Csaction，通过deposit_csaction存储；
2. 对Csaction的进行处理，这个处理将会更新世界树的状态。

与传统的区块交易处理相比，增加了一个Csaction，理论上，Csaction将会被传输到需要对应分片中，由于网络是多层架构的（3层及以上），为了避免Csaction在不相干的链（中继/信标）中传输浪费带宽资源，在区块打包时，需要对存储的csaction进行以下的操作：
1. 是否为要求本分片处理的csaction，如果需要，直接处理后删除
2. 如果是需要其他分片处理的，根据目标分片以及系统中相应的分片指数，把Csaction分层打包，把原始的csaction数据存入到链外存储，然后记录每一层的（目标/哈希值），把最后一层的`Vec<（目标/哈希）>` 打包进入区块

## Csaction生成和处理方式
根据上述的处理过程，Csaction是由交易生成的，比如一个资产转移的交易，可以分解成在本分片上对某个帐号进行资产余额扣除和对可能是另外一个分片帐号的资产余额增加的过程，这个资产余额增加的过程就是csaction。  
为了保证数据一致性，即上述过程中的资产转移过程中，只要交易在原始的分片上被处理，那么对应的csaction早晚会被执行，为了保证这一点，我们使用区块锁定的方式:
1. 中继/分片/信标链区块中需要指示被打包进区块的其他角色链的区块信息（ChainRole,Height和Hash)，
2. 打包其他角色的链的区块信息时，必须按顺序打包而不能跳跃，即中继链打包分片链的区块信息中时，只有当分片的第N个区块已经被打包时，第N+1个区块才可以被打包。

一个角色的链，把其他角色的链的区块看成交易，通过交易池中的设立依赖关系来实现区块的顺序性。

交易生成Csaction时，是由交易的处理代码通过deposit_csaction来实现。deposit_csaction函数有两个参数:target和action。target参数指示该由什么链处理，而action就是处理的过程。此处需要注意的是，
1：由于action是经过编码来实现的，其编码方案与对应的runtime有关，而runtime是根据链层次不同与不同的，因此目前无法跨不同角色，例如分片链目前无法发送相应的csaction让信标链进行处理。 
2：target其实是chain_id（ChainRole类型)，由于系统是弹性分片的，这意味着交易需要根据当前的分片状态来决定target的结果。由于跨分片交易的延迟特性，即分片A区块高度N的csaction可能在中继的分片N+R，分片B的区块高度N+R+B上被处理，而在N+R或是N+R+B区块时，分片指数可能已经与N高度有变化了。csaction对应的AccountID已经不在分片B而是分片B‘中了，此处的B’是由分片B分裂而来。

### 弹性分片时的csaction处理
我们根据中继、信标和分片链不同的角色来来分析，假设在第N个块产生了弹性分片。 为了防止某个节色第N-1个区块处理了其他角色的第N个区块，我们作如下的约定以简化系统的处理方案：任何一个高度为M的区块，只可以处理其他角色中不大于M高度的区块。有了这个前提条件，各个角色的处理过程可以如下所述：

#### 中继链的处理过程
1. 中继链在第N块时，打包了分片A的第N-1个区块BA<sub>N-1</sub>，由于区块中BA<sub>N-1</sub>的CsaResults还是按照分片前的组织的，中继将BA<sub>N-1</sub>中的CsaResults按照分片后的结果，同一个CsaResults项目，即(target,hash)根据target分别按照新的分片指数，生成新的记录。
2. 中继链在区块高度N+1上处理信标链的第N个区块，信标链中的分片方案还是更新前的，推断出本中继处理的所有分片数据，根据新的分片方案，分析所有的分片数据，给相应的分片处理。

#### 信标链处理
1. 信标链在第N块时时，处理中继链的第N-1块区块数据方案，直接根据新的分片方案，把原有的数据一分为二，生成两条记录，由中继链按照自己的方式处理。

#### 分片链处理
分片链在第N+K个区块时，收到中继链的第N个区块的数据方案，解开后，对所有的Csaction进行处理，如果Csaction中的目标不在本分片上，可以直接丢弃。

在上述的处理方案中，在分片切换时，有些Csaction可能会被两个分片处理，上述方案的处理原则是：通过冗余传输保证数据传输的可靠性，通过最终的处理者决定处理的一致性。事实上，对于类似于资产转移这样的交易来说，即使在两个分片上都被加了一次，也不会产生问题，因为后续的其他的节点都是会向正确的分片上查询相应的AccountId的数据。

### csaction的合并与归纳
Csaction在execute_block过程的每个ApplyExtrinsic过程中，由对应的Callable函数通过deposit_csaction来生成。如果不作处理，Csactions需要通过中继链、信标链、目标中继链，目标分片链一系列的转发，而实际上中间的节点并不关心实际的csaction，因此从节约带宽的角度来说，也不应该关心和传输，因此我们需要对csaction再作处理：把同一个target的所有的csaction合并，合并后的结果生成哈希，即Hash=vec![action1,...actionN]，然后得到一组根据不同的target得到的结果Vec<(target,Hash)>，这一组结果，我们称为CsaResults，打包进区块。这个过程在block的on_finalize时，由
proc_csaction来进行处理。



## <span id="proc">跨分片交易生成处理--生成Csaction</span>
如上所述，跨分片交易分成两种，原始交易和区块交易，在目前的实现中，原始交易只有在分片区块上被处理，而区块交易在三种链的角色上都会被处理。既然是交易，可以被设计成由pallet处理，因此此处只是对原始交易需要得到跨分片结果的部分进行描述，重点描述区块交易的处理方案
### 原始交易处理
原始交易通过deposit_csaction进行处理
### 区块交易处理
#### 分片链处理区块交易
分片链总是处理来自于对应中继链的处理交易：
1. 从中继的downstream中可以得到给自身的(ChaiRole,Hash)对
2. 从链外存储中获取Hash对应的Vec<Csaction>
3. 通过deposit_csaction存储Csaction

#### 中继链处理区块交易
中继链需要处理来自于下属分片的区块交易和信标链的区块交易
##### 分片链区块交易处理
1. 分片区块中的upstream中的每一条，通过deposit_csaction插入到存储中

##### 信标链区块交易
1. 从信标区块中的downstream得到需要自己处理的(ChainRole,Hash)对
2. 根据哈希从链外存储中获取对应的`Vec<Hash>`
3. 把数组中的每一个哈希，生成一个新的csaction，通过deposit_csaction存储


#### 信标链处理区块交易
信标链处理中继的区块交易
1. 读取每个中继分片中的upstream中的每一条，生成csaction存储


## 处理csaction
生成csaction都是有一个target，根据这个target进行不同的处理：
1. 如果target是自身，那么就调用相应的Csaction.execute
2. 如果target不是自身，那么就根据不同的target来合并同一个target的Csactions，
	1. 同一组csaction生成哈希，数据存入到链外存储
	2. 记录(target,hash)
3. 根据不同的target生成CsaResults

# 详细设计



## 区块作为交易的处理过程
当使用一条链使用其他链的区块作为交易时，显然这条链需要获取其他链的区块信息，在此意义上，这条链观察相关链的出块信息，并且在合适的时候，把其他相关链的区块信息作为交易打包进入自身的区块。显然，当相关链的区块信息被打包进本链时，可以看成本链将这些区块锁定了，如果被锁定的链发生回滚，那么本链也需要被回滚，这样就产生了回滚雪崩问题。 因此，我们做如下的约束：本链需要处理相关链中不再会被回滚的区块或者相关链中跟踪本链锁定的区块，一旦发现某个区块被锁定，就再也不会回滚。本方案中使用前者，即相关链中的区块最终确定化后才会被打包进入区块。  

打包区块的链需要了解相关链中的某些区块是否已经被最终确定化，无疑本链需要记录相关链中的区块链信息，才能够了解是否已经最终确定化，这个模式与轻节点的模式是类似的。之所以是类似，是因为轻节点向全节点请求同步数据，轻节点之间不需要同步数据，而本链还需要向链内的其他节点提供数据。

考虑一个区块的出块过程：  
1. 链节点作为观察者监视相关的链
2. 当相关的链出块时，节点存储该区块的信息（区块头，csaresults)
3. 节点验证该区块是否为已经最终确定化了，如果是已经最终确定化了，生成一笔交易，放入交易池
4. 交易池将该交易进行广播
5. 当可以出块时，将交易池内的交易打包生成区块，并且广播通告

一个节点收到其他节点出块的过程：
* 交易生成过程一
1. 链节点作为观察者监视相关的链
2. 当相关的链出块时，节点存储该区块的信息（区块头，csaresults)
3. 节点验证该区块是否为已经最终确定化了，如果是已经最终确定化了，生成一笔交易，放入交易池

* 交易生成过程二
1. 收到交易广播，本节点交易池中还没有
2. 请求来源节点交易中的相关区块信息
3. 验证相关区块信息是否可以生成交易，如果可以，生成并且放入交易池

* 收到其他节点发布的新区块
1. 把区块中所有的交易放入交易池，如果交易池中没有，按上述的交易生成过程二执行
2. 执行导入区块


### 可验证的交易数据
当区块作为交易时，必须注意到的一点是，这个数据不是自验证的。所谓自验证就是交易的数据解码后，所有的交易相关的信息都可以从解码后的数据中获得。在未分片之前，所有的交易都是自验证的。而分片后，为了节省数据传输，情况就不一样了。
当把区块作为交易纳入到另外一条链时，交易自身的内容就是链ID，区块高度，哈希,而实际处理时，需要处理对应的区块体中的CsaResults值，因此被纳入到区块中的交易不是自验证的。所以需要作另外的处理。
详细的处理方案见《3.3-跨分片交易数据的存储》